<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: macros | (edtsech :notes)]]></title>
  <link href="http://edtsech.github.com/blog/categories/macros/atom.xml" rel="self"/>
  <link href="http://edtsech.github.com/"/>
  <updated>2013-01-20T15:33:48+01:00</updated>
  <id>http://edtsech.github.com/</id>
  <author>
    <name><![CDATA[Edward Tsech]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[And-let Macro in Clojure]]></title>
    <link href="http://edtsech.github.com/2012/12/and-let.html"/>
    <updated>2012-12-30T00:00:00+01:00</updated>
    <id>http://edtsech.github.com/2012/12/and-let</id>
    <content type="html"><![CDATA[<p>In Clojure we have two nice macros <a href="http://clojuredocs.org/clojure_core/clojure.core/if-let">if-let</a>
and <a href="http://clojuredocs.org/clojure_core/clojure.core/when-let">when-let</a>.</p>

<p>``` clj
(if-let [a ...]
  (inc a)
  0)</p>

<p>; or we can use <code>when-let</code> when we don't have <code>else</code> branch</p>

<p>(when-let [a ...]
  (inc a))
```</p>

<p>but unfortunately we can't pass more than two binding forms to
these macros, and emulate the behavior of Scheme's <a href="http://www.gnu.org/software/mit-scheme/documentation/mit-scheme-ref/and_002dlet_002a-_0028SRFI-2_0029.html">and-let</a>
or kind of maybe monad.</p>

<p>I mean smth like that:</p>

<p>``` clj
(and-let [a 1 b 2]</p>

<pre><code>     (+ a b)) ; =&gt; 3
</code></pre>

<p>(and-let [a 1 b nil]</p>

<pre><code>     (+ a b)) ; =&gt; nil
</code></pre>

<p>```</p>

<p>It isn't really hard to implement it:</p>

<p>``` clj
(defmacro and-let [bindings expr]
  (if (seq bindings)</p>

<pre><code>`(if-let [~(first bindings) ~(second bindings)]
   (and-let ~(drop 2 bindings) ~expr))
 expr))
</code></pre>

<p>(use 'clojure.walk)
(macroexpand-all '(and-let [a 1 b 2]</p>

<pre><code>                       (+ a b)))
</code></pre>

<p>; (let<em> [temp<strong>3971</strong>auto<strong> 1]
;   (if temp</strong>3971<strong>auto</strong>
;     (let</em> [a temp<strong>3971</strong>auto<strong>]
;       (let* [temp</strong>3971<strong>auto</strong> 2]
;         (if temp<strong>3971</strong>auto<strong>
;           (let* [b temp</strong>3971<strong>auto</strong>]
;             (+ a b))
;           nil)))
;     nil))</p>

<p>```</p>

<p>But we could do some improvements here: check count of binding form (should be even),
implement <code>else</code> clause, probably find a better name, implementation.</p>

<p>I'm not really sure about <code>else</code> clause, it can be very useful, but it sounds weird to have <code>else</code> part
with <code>and-let</code> name. I thought about <code>if-let*</code> and <code>when-let*</code> names, it looks idiomatic for other Lisps
but not for Clojure I think.</p>

<p>I think Clojure way, will be - change a behavior of <code>if-let</code> and <code>when-let</code> macros in Clojure to support
more than two binding forms, because <code>let</code> already does it.</p>

<p>Wdyt?</p>

<p>PS. Another option is use the maybe monad from <code>algo.monads</code> but it's extra dependency for relatively
small amount of code (if you don't plan use monads really often) and slightly different behavior.</p>

<h2>Peace!</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Do unless]]></title>
    <link href="http://edtsech.github.com/2012/11/do-unless.html"/>
    <updated>2012-11-20T00:00:00+01:00</updated>
    <id>http://edtsech.github.com/2012/11/do-unless</id>
    <content type="html"><![CDATA[<p>Whilst experimenting with <a href="https://github.com/semperos/clj-webdriver">clj-webdriver</a>
and writing <a href="https://github.com/edtsech/social-phobia">social-phobia</a>
I have created an interesting macro and would like to share it with you and get some feedback.</p>

<p>Lets write some simple script, log in to GitHub</p>

<p><code>clj
(set-driver! {:browser :firefox})
(to "https://github.com/login")
(input-text "#login_field" (auth :login))
(input-text "#password" (auth :pass))
(click {:xpath "//input[@type='submit']"})
...
</code></p>

<p>If we have wrong URL or don't have an element on the page, we basically get that:</p>

<p><code>clj
NullPointerException   clojure.lang.Reflector.invokeInstanceMethod (Reflector.java:26)
</code></p>

<p>In a different way we can get the same result like this:</p>

<p>``` clj
=> (def el (find-element {:css "#login_fiel"}))</p>

<h1>'user/el</h1>

<p>=> el</p>

<h1>clj_webdriver.element.Element{:webelement nil}</h1>

<p>=> (input-text el "asd")
NullPointerException   clojure.lang.Reflector.invokeInstanceMethod (Reflector.java:26)
```</p>

<p>Awesome. But I would like to receive more useful messages if GitHub changes URL or IDs of HTML elements.
Let's make our code "safer":</p>

<p>``` clj
(defn error
  "Returns \"\"#uername\" not found\" for e.g."
  [selector]
  {:error (str (first (vals selector)) " not found")})</p>

<p>(defn safe-find-element
  "Find the element, if the element is found, call the f,
  if not return a map with an error."
  [selector f]
  (let [el (find-element selector)]</p>

<pre><code>(if (:webelement el)
  (f el)
  (error selector))))
</code></pre>

<p>```</p>

<p>It means if we find an element we call function with that element,
if not we return error which looks like <code>{error: "#signin-email not found"}</code>.
Nice, but not so useful so far.
Let's wrap <code>click</code> and <code>input-text</code> functions in this wrapper.</p>

<p>``` clj
(defn- safe-input-text [selector text]
  (safe-find-element selector</p>

<pre><code>                 #(-&gt; %
                    clear
                    (input-text text))))
</code></pre>

<p>(defn- safe-click [selector]
  (safe-find-element selector #(click %)))
```</p>

<p>Let's see how it works:</p>

<p><code>clj
=&gt; (safe-input-text {:css "#login_fiel"} "asd")
{:error "#login_fiel not found"}
</code></p>

<p>And try to rewrite our code:</p>

<p>``` clj
(set-driver! {:browser :firefox})
(to "https://github.com/login")
(or (:error (safe-input-text {:css "#login_field"} (auth :login)))</p>

<pre><code>(:error (safe-input-text {:css "#password"} (auth :pass)))
(:error (safe-click {:xpath "//input[@type='submit']"})))
</code></pre>

<p>```</p>

<p>Hm, it's not so DRY.</p>

<p>``` clj
=> (do-unless :error (safe-input-text {:css "#login_field"} (auth :login))</p>

<pre><code>                 (safe-input-text {:css "#passwor"} (auth :pass))
                 (safe-click {:xpath "//input[@type='submit']"}))
</code></pre>

<p>{:error "#passwor not found"}
```</p>

<p>Much nicer. But how is it supposed to work? Tada!</p>

<p>``` clj
(defmacro do-unless
  "
  Evaluates the expr if the condition which was called
  with result of previous expression returned false.</p>

<p>  Examples:
  =========</p>

<p>  (do-unless nil? (println 1) (println 2))
  1
  nil
  (do-unless nil? (do (println 1) 1) (println 2))
  1
  2
  nil"
  ([condition expr &amp; exprs]
   `(let [r# ~expr]</p>

<pre><code>  (if (~condition r#)
    r#
    (do-unless ~condition ~@exprs))))
</code></pre>

<p>  ([condition expr]
   expr))
```</p>

<p>Macroexpand:</p>

<p>``` clj
(macroexpand '(do-unless :error (safe-input-text {:css "#login_field"} (auth :login))</p>

<pre><code>                 (safe-input-text {:css "#passwor"} (auth :pass))
                 (safe-click {:xpath "//input[@type='submit']"})))
</code></pre>

<p>(let* [r<strong>1016</strong>auto<strong> (safe-input-text {:css "#login_field"} (auth :login))]
  (if (:error r</strong>1016<strong>auto</strong>)</p>

<pre><code>  r__1016__auto__
  (social-phobia.core/do-unless :error
                                (safe-input-text {:css "#passwor"} (auth :pass))
                                (safe-click {:xpath "//input[@type='submit']"}))))
</code></pre>

<p>```</p>

<p>Basically this macro recursively produces, a set of nested <code>let</code> and <code>if</code> expressions.</p>

<ol>
<li>Cache result of expression</li>
<li>Check is't map with <code>:error</code> message or not</li>
<li>If yes, returns that map</li>
<li>If not start this cycle for next expression</li>
</ol>


<p>Nice, also it should be faster than catch exceptions and also
we don't produce any extra function calls like we do with monads.
I think this macro is pretty much fun for this kind of code with a purely
imperative nature.</p>

<p>Wdyt?</p>

<h2>Peace!</h2>
]]></content>
  </entry>
  
</feed>
