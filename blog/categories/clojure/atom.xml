<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: clojure | Edward Tsech]]></title>
  <link href="http://edtsech.github.com/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://edtsech.github.com/"/>
  <updated>2013-05-24T21:10:29+02:00</updated>
  <id>http://edtsech.github.com/</id>
  <author>
    <name><![CDATA[Edward Tsech]]></name>
    <email><![CDATA[edtsech@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[And-let Macro in Clojure]]></title>
    <link href="http://edtsech.github.com/2012/12/and-let.html"/>
    <updated>2012-12-30T00:00:00+01:00</updated>
    <id>http://edtsech.github.com/2012/12/and-let</id>
    <content type="html"><![CDATA[<p>In Clojure we have two nice macros <a href="http://clojuredocs.org/clojure_core/clojure.core/if-let">if-let</a>
and <a href="http://clojuredocs.org/clojure_core/clojure.core/when-let">when-let</a>.</p>

<p>``` clj
(if-let [a ...]
  (inc a)
  0)</p>

<p>; or we can use <code>when-let</code> when we don't have <code>else</code> branch</p>

<p>(when-let [a ...]
  (inc a))
```</p>

<p>but unfortunately we can't pass more than two binding forms to
these macros, and emulate the behavior of Scheme's <a href="http://www.gnu.org/software/mit-scheme/documentation/mit-scheme-ref/and_002dlet_002a-_0028SRFI-2_0029.html">and-let</a>
or kind of maybe monad.</p>

<p>I mean smth like that:</p>

<p>``` clj
(and-let [a 1 b 2]</p>

<pre><code>     (+ a b)) ; =&gt; 3
</code></pre>

<p>(and-let [a 1 b nil]</p>

<pre><code>     (+ a b)) ; =&gt; nil
</code></pre>

<p>```</p>

<p>It isn't really hard to implement it:</p>

<p>``` clj
(defmacro and-let [bindings expr]
  (if (seq bindings)</p>

<pre><code>`(if-let [~(first bindings) ~(second bindings)]
   (and-let ~(drop 2 bindings) ~expr))
 expr))
</code></pre>

<p>(use 'clojure.walk)
(macroexpand-all '(and-let [a 1 b 2]</p>

<pre><code>                       (+ a b)))
</code></pre>

<p>; (let<em> [temp<strong>3971</strong>auto<strong> 1]
;   (if temp</strong>3971<strong>auto</strong>
;     (let</em> [a temp<strong>3971</strong>auto<strong>]
;       (let* [temp</strong>3971<strong>auto</strong> 2]
;         (if temp<strong>3971</strong>auto<strong>
;           (let* [b temp</strong>3971<strong>auto</strong>]
;             (+ a b))
;           nil)))
;     nil))</p>

<p>```</p>

<p>But we could do some improvements here: check count of binding form (should be even),
implement <code>else</code> clause, probably find a better name, implementation.</p>

<p>I'm not really sure about <code>else</code> clause, it can be very useful, but it sounds weird to have <code>else</code> part
with <code>and-let</code> name. I thought about <code>if-let*</code> and <code>when-let*</code> names, it looks idiomatic for other Lisps
but not for Clojure I think.</p>

<p>Wdyt?</p>

<p>PS. Another option is use the maybe monad from <code>algo.monads</code> but it's extra dependency for relatively
small amount of code (if you don't plan use monads really often) and slightly different behavior.</p>

<h2>Peace!</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Do unless]]></title>
    <link href="http://edtsech.github.com/2012/11/do-unless.html"/>
    <updated>2012-11-20T00:00:00+01:00</updated>
    <id>http://edtsech.github.com/2012/11/do-unless</id>
    <content type="html"><![CDATA[<p>Whilst experimenting with <a href="https://github.com/semperos/clj-webdriver">clj-webdriver</a>
and writing <a href="https://github.com/edtsech/social-phobia">social-phobia</a>
I have created an interesting macro and would like to share it with you and get some feedback.</p>

<p>Lets write some simple script, log in to GitHub</p>

<p><code>clj
(set-driver! {:browser :firefox})
(to "https://github.com/login")
(input-text "#login_field" (auth :login))
(input-text "#password" (auth :pass))
(click {:xpath "//input[@type='submit']"})
...
</code></p>

<p>If we have wrong URL or don't have an element on the page, we basically get that:</p>

<p><code>clj
NullPointerException   clojure.lang.Reflector.invokeInstanceMethod (Reflector.java:26)
</code></p>

<p>In a different way we can get the same result like this:</p>

<p>``` clj
=> (def el (find-element {:css "#login_fiel"}))</p>

<h1>'user/el</h1>

<p>=> el</p>

<h1>clj_webdriver.element.Element{:webelement nil}</h1>

<p>=> (input-text el "asd")
NullPointerException   clojure.lang.Reflector.invokeInstanceMethod (Reflector.java:26)
```</p>

<p>Awesome. But I would like to receive more useful messages if GitHub changes URL or IDs of HTML elements.
Let's make our code "safer":</p>

<p>``` clj
(defn error
  "Returns \"\"#uername\" not found\" for e.g."
  [selector]
  {:error (str (first (vals selector)) " not found")})</p>

<p>(defn safe-find-element
  "Find the element, if the element is found, call the f,
  if not return a map with an error."
  [selector f]
  (let [el (find-element selector)]</p>

<pre><code>(if (:webelement el)
  (f el)
  (error selector))))
</code></pre>

<p>```</p>

<p>It means if we find an element we call function with that element,
if not we return error which looks like <code>{error: "#signin-email not found"}</code>.
Nice, but not so useful so far.
Let's wrap <code>click</code> and <code>input-text</code> functions in this wrapper.</p>

<p>``` clj
(defn- safe-input-text [selector text]
  (safe-find-element selector</p>

<pre><code>                 #(-&gt; %
                    clear
                    (input-text text))))
</code></pre>

<p>(defn- safe-click [selector]
  (safe-find-element selector #(click %)))
```</p>

<p>Let's see how it works:</p>

<p><code>clj
=&gt; (safe-input-text {:css "#login_fiel"} "asd")
{:error "#login_fiel not found"}
</code></p>

<p>And try to rewrite our code:</p>

<p>``` clj
(set-driver! {:browser :firefox})
(to "https://github.com/login")
(or (:error (safe-input-text {:css "#login_field"} (auth :login)))</p>

<pre><code>(:error (safe-input-text {:css "#password"} (auth :pass)))
(:error (safe-click {:xpath "//input[@type='submit']"})))
</code></pre>

<p>```</p>

<p>Hm, it's not so DRY.</p>

<p>``` clj
=> (do-unless :error (safe-input-text {:css "#login_field"} (auth :login))</p>

<pre><code>                 (safe-input-text {:css "#passwor"} (auth :pass))
                 (safe-click {:xpath "//input[@type='submit']"}))
</code></pre>

<p>{:error "#passwor not found"}
```</p>

<p>Much nicer. But how is it supposed to work? Tada!</p>

<p>``` clj
(defmacro do-unless
  "
  Evaluates the expr if the condition which was called
  with result of previous expression returned false.</p>

<p>  Examples:
  =========</p>

<p>  (do-unless nil? (println 1) (println 2))
  1
  nil
  (do-unless nil? (do (println 1) 1) (println 2))
  1
  2
  nil"
  ([condition expr &amp; exprs]
   `(let [r# ~expr]</p>

<pre><code>  (if (~condition r#)
    r#
    (do-unless ~condition ~@exprs))))
</code></pre>

<p>  ([condition expr]
   expr))
```</p>

<p>Macroexpand:</p>

<p>``` clj
(macroexpand '(do-unless :error (safe-input-text {:css "#login_field"} (auth :login))</p>

<pre><code>                 (safe-input-text {:css "#passwor"} (auth :pass))
                 (safe-click {:xpath "//input[@type='submit']"})))
</code></pre>

<p>(let* [r<strong>1016</strong>auto<strong> (safe-input-text {:css "#login_field"} (auth :login))]
  (if (:error r</strong>1016<strong>auto</strong>)</p>

<pre><code>  r__1016__auto__
  (social-phobia.core/do-unless :error
                                (safe-input-text {:css "#passwor"} (auth :pass))
                                (safe-click {:xpath "//input[@type='submit']"}))))
</code></pre>

<p>```</p>

<p>Basically this macro recursively produces, a set of nested <code>let</code> and <code>if</code> expressions.</p>

<ol>
<li>Cache result of expression</li>
<li>Check is't map with <code>:error</code> message or not</li>
<li>If yes, returns that map</li>
<li>If not start this cycle for next expression</li>
</ol>


<p>Nice, also it should be faster than catch exceptions and also
we don't produce any extra function calls like we do with monads.
I think this macro is pretty much fun for this kind of code with a purely
imperative nature.</p>

<p>Wdyt?</p>

<h2>Peace!</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Templating]]></title>
    <link href="http://edtsech.github.com/2012/09/clojure-templating.html"/>
    <updated>2012-09-07T00:00:00+02:00</updated>
    <id>http://edtsech.github.com/2012/09/clojure-templating</id>
    <content type="html"><![CDATA[<p>In this note I would like to describe current situation of dealing with templates in Clojure.
We have four most known options:</p>

<ul>
<li><a href="https://github.com/fhd/clostache" title="">Clostache</a></li>
<li><a href="https://github.com/cgrand/enlive" title="">Enlive</a></li>
<li><a href="https://github.com/Flamefork/fleet" title="">Fleet</a></li>
<li><a href="https://github.com/weavejester/hiccup">Hiccup</a></li>
</ul>


<p>Let's start with Fleet. Fleet is pretty similar to old ERB or JSP way of working with templates:</p>

<p>``` clj</p>

<p><(post :body)></p>
```

In fact it's not so popular in Clojure world probably because main philosophy of Lisp is
"code as data". And it's also true for templates. It's where Hiccup shines:

``` clj
[:p (post :body)]
```

As you can see, it's just Clojure vector, first element of this vector is tag name and second one is content.
You can add attributes to the tag:

``` clj
[:link {:href "www.example.com"} "Example"]
```

We can easily make abstraction on it and keep it as a helper:

``` clj
(defn link [href name] [:link {:href href} name])
(link "www.example.com" "Example")
; => [:link {:href "www.example.com"} "Example"]
```

For converting it to html you need to pass it to `html` function:

``` clj
(html (link "www.example.com" "Example"))
; => "<a href=\"www.example.com\">Example</a> "
```

You can make your own collection of helpers and partials which will be easy to embed in your code.
lso you can find basic low-lewel helpers as `link-to` and `form-to` and so on in Hiccup
[itself](https://github.com/weavejester/hiccup/blob/master/src/hiccup/element.clj).
Hiccup is quite popular in Clojure comunity and it's used as part of
[Noir framework](webnoir.org).
You don't have to write Hiccup templates by yourself if you already have HTML file from a designer, there are some
[tools](https://github.com/weavejester/hiccup/wiki/Converting-html-to-hiccup) which can help you to convert HTML file to Hiccup.

If you are sceptic about all this stuff like \"code as data\" in templates you're able to choose Clostache.
It's just [Mustache](http://mustache.github.com/)
implementation in Clojure. I think you already know that. This how it looks in Clojure.

``` clj
(render "Hello, !" {:name "Felix"})
```

Also we have some pretty interesting approach which calls Enlive, it's similar to XSLT transformation,
but instead of noisy XML we have Clojure which is Lisp which is executable XML :)
The main idea is keep our html for a designer. Just do nothing with it.
No ERB templates, Mustache or any other templates. Just plain HTML and transformations.
There is a little bit more code for explanation how it works that is why I've placed this code to the
[gist](https://gist.github.com/3672297).

I think it will be unuseful try to describe pros and cons of each of these template libraries,
because it's really depends on which process you use to work with your templates.

Also there is fifth hidden option is use templating on the front-end :)

## Peace!

]]></content>
  </entry>
  
</feed>
